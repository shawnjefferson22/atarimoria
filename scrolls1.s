;
; File generated by cc65 v 2.14 - Git 6df4205
;
	.fopt		compiler,"cc65 v 2.14 - Git 6df4205"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.import		_sprintf
	.import		_vbxe_bank
	.import		_vbxe_restore_bank
	.import		_out_val1
	.import		_out_val2
	.import		_new_level_flag
	.import		_free_turn_flag
	.import		_dun_level
	.importzp	_panel_row_min
	.importzp	_panel_row_max
	.importzp	_panel_col_min
	.importzp	_panel_col_max
	.import		_crow_lookup
	.import		_py
	.importzp	_char_row
	.importzp	_char_col
	.import		_object_list
	.import		_object_ident
	.import		_t_list
	.import		_inventory
	.import		_inven_ctr
	.importzp	_tcptr
	.import		_randint
	.import		_bank_aggravate_monster
	.import		_bank_calc_bonuses
	.import		_bank_compact_objects
	.import		_bank_create_food
	.import		_bank_delete_object
	.import		_bank_desc_remain
	.import		_bank_destroy_area
	.import		_bank_detect_invisible
	.import		_bank_detect_treasure
	.import		_bank_detect_object
	.import		_bank_detect_trap
	.import		_bank_detect_sdoor
	.import		_bank_dispel_creature
	.import		_bank_genocide
	.import		_bank_get_item
	.import		_bank_ident_spell
	.import		_bank_identify
	.import		_bank_inven_destroy
	.import		_bank_light_area
	.import		_bank_map_area
	.import		_bank_mass_genocide
	.import		_bank_msg_print
	.import		_bank_objdes
	.import		_bank_place_trap
	.import		_bank_print_symbol
	.import		_bank_protect_evil
	.import		_bank_prt_experience
	.import		_bank_py_bonuses
	.import		_bank_recharge
	.import		_bank_remove_curse
	.import		_bank_sleep_monsters1
	.import		_bank_summon_monster
	.import		_bank_summon_undead
	.import		_bank_td_destroy
	.import		_bank_teleport
	.import		_bank_unlight_area
	.import		_bank_warding_glyph
	.export		_scroll1_no_light
	.export		_scroll1_lite_spot
	.export		_scroll1_find_range
	.export		_scroll1_enchant
	.export		_scroll1_invcopy
	.export		_scroll1_object_offset
	.export		_scroll1_known1_p
	.export		_scroll1_sample
	.export		_scroll1_bit_pos
	.export		_scroll1_popt
	.export		_trap_creation
	.export		_door_creation
	.export		_read_scroll

.segment	"DATA"

.segment	"SCROLL1BANK"

.segment	"RODATA"

.segment	"SCROLL1BANK"
L02DC:
	.byte	$59,$6F,$75,$20,$66,$65,$65,$6C,$20,$61,$73,$20,$69,$66,$20,$73
	.byte	$6F,$6D,$65,$6F,$6E,$65,$20,$69,$73,$20,$77,$61,$74,$63,$68,$69
	.byte	$6E,$67,$20,$6F,$76,$65,$72,$20,$79,$6F,$75,$2E,$00
L01A7:
	.byte	$59,$6F,$75,$20,$61,$72,$65,$20,$74,$6F,$6F,$20,$63,$6F,$6E,$66
	.byte	$75,$73,$65,$64,$20,$74,$6F,$20,$72,$65,$61,$64,$20,$61,$20,$73
	.byte	$63,$72,$6F,$6C,$6C,$2E,$00
L036A:
	.byte	$54,$68,$65,$72,$65,$20,$69,$73,$20,$61,$20,$68,$69,$67,$68,$20
	.byte	$70,$69,$74,$63,$68,$65,$64,$20,$68,$75,$6D,$6D,$69,$6E,$67,$20
	.byte	$6E,$6F,$69,$73,$65,$2E,$00
L0580:
	.byte	$54,$68,$65,$20,$61,$69,$72,$20,$61,$62,$6F,$75,$74,$20,$79,$6F
	.byte	$75,$20,$62,$65,$63,$6F,$6D,$65,$73,$20,$63,$68,$61,$72,$67,$65
	.byte	$64,$2E,$00
L01BB:
	.byte	$59,$6F,$75,$20,$61,$72,$65,$20,$6E,$6F,$74,$20,$63,$61,$72,$72
	.byte	$79,$69,$6E,$67,$20,$61,$6E,$79,$20,$73,$63,$72,$6F,$6C,$6C,$73
	.byte	$21,$00
L0199:
	.byte	$59,$6F,$75,$20,$63,$61,$6E,$27,$74,$20,$73,$65,$65,$20,$74,$6F
	.byte	$20,$72,$65,$61,$64,$20,$74,$68,$65,$20,$73,$63,$72,$6F,$6C,$6C
	.byte	$2E,$00
L0356:
	.byte	$54,$68,$69,$73,$20,$69,$73,$20,$61,$20,$6D,$61,$73,$73,$20,$67
	.byte	$65,$6E,$6F,$63,$69,$64,$65,$20,$73,$63,$72,$6F,$6C,$6C,$2E,$00
L037D:
	.byte	$54,$68,$69,$73,$20,$69,$73,$20,$61,$20,$52,$65,$63,$68,$61,$72
	.byte	$67,$65,$2D,$49,$74,$65,$6D,$20,$73,$63,$72,$6F,$6C,$6C,$2E,$00
L01AE:
	.byte	$59,$6F,$75,$20,$61,$72,$65,$20,$6E,$6F,$74,$20,$63,$61,$72,$72
	.byte	$79,$69,$6E,$67,$20,$61,$6E,$79,$74,$68,$69,$6E,$67,$21,$00
L01A0:
	.byte	$59,$6F,$75,$20,$68,$61,$76,$65,$20,$6E,$6F,$20,$6C,$69,$67,$68
	.byte	$74,$20,$74,$6F,$20,$72,$65,$61,$64,$20,$62,$79,$2E,$00
L0531:
	.byte	$59,$6F,$75,$72,$20,$25,$73,$20,$67,$6C,$6F,$77,$73,$20,$62,$6C
	.byte	$61,$63,$6B,$2C,$20,$66,$61,$64,$65,$73,$2E,$00
L040A	:=	L0531+0
L02C3:
	.byte	$54,$68,$69,$73,$20,$69,$73,$20,$61,$6E,$20,$69,$64,$65,$6E,$74
	.byte	$69,$66,$79,$20,$73,$63,$72,$6F,$6C,$6C,$2E,$00
L0389:
	.byte	$54,$68,$69,$73,$20,$69,$73,$20,$61,$20,$67,$65,$6E,$6F,$63,$69
	.byte	$64,$65,$20,$73,$63,$72,$6F,$6C,$6C,$2E,$00
L058D:
	.byte	$49,$6E,$74,$65,$72,$6E,$61,$6C,$20,$65,$72,$72,$6F,$72,$20,$69
	.byte	$6E,$20,$73,$63,$72,$6F,$6C,$6C,$28,$29,$00
L0325:
	.byte	$59,$6F,$75,$72,$20,$68,$61,$6E,$64,$73,$20,$62,$65,$67,$69,$6E
	.byte	$20,$74,$6F,$20,$67,$6C,$6F,$77,$2E,$00
L048D:
	.byte	$59,$6F,$75,$72,$20,$25,$73,$20,$67,$6C,$6F,$77,$73,$20,$62,$72
	.byte	$69,$67,$68,$74,$6C,$79,$21,$00
L03B6	:=	L048D+0
L04B0:
	.byte	$54,$68,$65,$20,$65,$6E,$63,$68,$61,$6E,$74,$6D,$65,$6E,$74,$20
	.byte	$66,$61,$69,$6C,$73,$2E,$00
L01F6:
	.byte	$59,$6F,$75,$72,$20,$25,$73,$20,$67,$6C,$6F,$77,$73,$20,$66,$61
	.byte	$69,$6E,$74,$6C,$79,$21,$00
L0209	:=	L04B0+0
L021C	:=	L01F6+0
L023E	:=	L04B0+0
L02AA	:=	L01F6+0
L02BB	:=	L04B0+0
L03F7	:=	L04B0+0
L01C2:
	.byte	$52,$65,$61,$64,$20,$77,$68,$69,$63,$68,$20,$73,$63,$72,$6F,$6C
	.byte	$6C,$3F,$00
L01C8	:=	L02DC+44

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ scroll1_no_light (void)
; ---------------------------------------------------------------

.segment	"SCROLL1BANK"

.proc	_scroll1_no_light: near

.segment	"SCROLL1BANK"

;
; register cave_type *c_ptr;
;
	lda     regbank+4
	ldx     regbank+5
	jsr     pushax
;
; vbxe_bank(VBXE_CAVBANK);      // bank in cave, no need to restore bank
;
	lda     #$A8
	jsr     _vbxe_bank
;
; c_ptr = CAVE_ADR(char_row, char_col);
;
	ldx     #$00
	lda     _char_row
	asl     a
	bcc     L0632
	inx
	clc
L0632:	adc     #<(_crow_lookup)
	sta     ptr1
	txa
	adc     #>(_crow_lookup)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     ptr1
	stx     ptr1+1
	lda     _char_col
	ldx     #$00
	jsr     shlax2
	clc
	adc     ptr1
	sta     regbank+4
	txa
	adc     ptr1+1
	sta     regbank+4+1
;
; if (!(c_ptr->flags & CAVE_TL) && !(c_ptr->flags & CAVE_PL))
;
	ldy     #$03
	lda     (regbank+4),y
	ldx     #$00
	and     #$08
	bne     L0633
	lda     (regbank+4),y
	and     #$04
	beq     L0634
L0633:	txa
	jmp     L0071
;
; return TRUE;
;
L0634:	lda     #$01
;
; }
;
L0071:	pha
	lda     (sp,x)
	sta     regbank+4
	ldy     #$01
	lda     (sp),y
	sta     regbank+5
	pla
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ __fastcall__ scroll1_lite_spot (unsigned char, unsigned char)
; ---------------------------------------------------------------

.segment	"SCROLL1BANK"

.proc	_scroll1_lite_spot: near

.segment	"SCROLL1BANK"

;
; {
;
	jsr     pusha
;
; if ((y >= panel_row_min) && (y <= panel_row_max) && (x >= panel_col_min) && (x <= panel_col_max))
;
	ldy     #$01
	lda     (sp),y
	jsr     pusha0
	lda     _panel_row_min
	bpl     L0086
	ldx     #$FF
L0086:	jsr     tosicmp
	bcc     L0083
	ldy     #$01
	lda     (sp),y
	jsr     pusha0
	lda     _panel_row_max
	bpl     L0089
	ldx     #$FF
L0089:	jsr     tosicmp
	beq     L0636
	bcs     L0083
L0636:	ldx     #$00
	lda     (sp,x)
	cmp     _panel_col_min
	txa
	sbc     _panel_col_min+1
	bcc     L0083
	lda     (sp,x)
	sec
	sbc     _panel_col_max
	sta     tmp1
	txa
	sbc     _panel_col_max+1
	ora     tmp1
	bcc     L0639
	jne     incsp2
;
; bank_print_symbol(y, x, SCROLL1NUM);
;
L0639:	jsr     decsp2
	ldy     #$03
	lda     (sp),y
	ldy     #$01
	sta     (sp),y
	iny
	lda     (sp),y
	ldy     #$00
	sta     (sp),y
	lda     #$29
	jsr     _bank_print_symbol
;
; }
;
L0083:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ scroll1_find_range (unsigned char, unsigned char, __near__ unsigned char*, __near__ unsigned char*)
; ---------------------------------------------------------------

.segment	"SCROLL1BANK"

.proc	_scroll1_find_range: near

.segment	"SCROLL1BANK"

;
; {
;
	jsr     pushax
;
; register int8u i;
;
	lda     regbank+5
	jsr     pusha
;
; register inven_type *i_ptr;
;
	lda     regbank+3
	ldx     regbank+4
	jsr     pushax
;
; i = 0;
;
	jsr     decsp1
	lda     #$00
	sta     regbank+5
;
; *j = 255;       // was -1, rewrote to avoid negative values
;
	ldy     #$07
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     #$FF
	ldy     #$00
	sta     (ptr1),y
;
; *k = 255;
;
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     #$FF
	ldy     #$00
	sta     (ptr1),y
;
; flag = FALSE;
;
	tya
	sta     (sp),y
;
; vbxe_bank(VBXE_OBJBANK);
;
	lda     #$88
	jsr     _vbxe_bank
;
; i_ptr = &inventory[0];
;
	lda     #<(_inventory)
	sta     regbank+3
	lda     #>(_inventory)
	sta     regbank+3+1
;
; while (i < inven_ctr) {
;
	jmp     L00A1
;
; if (!flag) {
;
L009F:	ldy     #$00
	lda     (sp),y
	bne     L00A3
;
; if ((i_ptr->tval == item1) || (i_ptr->tval == item2)) {
;
	ldy     #$14
	lda     (regbank+3),y
	ldy     #$09
	cmp     (sp),y
	beq     L063E
	ldy     #$14
	lda     (regbank+3),y
	ldy     #$08
	cmp     (sp),y
	bne     L0642
;
; flag = TRUE;
;
L063E:	lda     #$01
	ldy     #$00
	sta     (sp),y
;
; *j = i;
;
	ldy     #$07
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     regbank+5
	ldy     #$00
	sta     (ptr1),y
;
; else {
;
	jmp     L0642
;
; if ((i_ptr->tval != item1) && (i_ptr->tval != item2)) {
;
L00A3:	ldy     #$14
	lda     (regbank+3),y
	ldy     #$09
	cmp     (sp),y
	beq     L0642
	ldy     #$14
	lda     (regbank+3),y
	ldy     #$08
	cmp     (sp),y
	beq     L0642
;
; *k = i - 1;
;
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     regbank+5
	sec
	sbc     #$01
	ldy     #$00
	sta     (ptr1),y
;
; break;
;
	jmp     L0643
;
; ++i;
;
L0642:	inc     regbank+5
;
; ++i_ptr;
;
	lda     #$28
	clc
	adc     regbank+3
	sta     regbank+3
	bcc     L00A1
	inc     regbank+3+1
;
; while (i < inven_ctr) {
;
L00A1:	lda     regbank+5
	cmp     _inven_ctr
	bcc     L009F
;
; if (flag && (*k == 255))
;
	ldy     #$00
L0643:	lda     (sp),y
	beq     L00BB
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$00
	lda     (ptr1),y
	cmp     #$FF
	bne     L00BB
;
; *k = inven_ctr - 1;
;
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     _inven_ctr
	sec
	sbc     #$01
	ldy     #$00
	sta     (ptr1),y
;
; vbxe_restore_bank();
;
L00BB:	jsr     _vbxe_restore_bank
;
; return(flag);
;
	ldx     #$00
	lda     (sp,x)
;
; }
;
	pha
	ldy     #$01
	lda     (sp),y
	sta     regbank+3
	iny
	lda     (sp),y
	sta     regbank+4
	iny
	lda     (sp),y
	sta     regbank+5
	pla
	ldy     #$0A
	jmp     addysp

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ scroll1_enchant (__near__ signed char*, signed char)
; ---------------------------------------------------------------

.segment	"SCROLL1BANK"

.proc	_scroll1_enchant: near

.segment	"SCROLL1BANK"

;
; {
;
	jsr     pusha
;
; if (limit <= 0) /* avoid randint(0) call */
;
	jsr     decsp2
	ldy     #$02
	lda     (sp),y
	sec
	sbc     #$01
	bvc     L00CA
	eor     #$80
L00CA:	asl     a
	lda     #$00
	bcc     L064B
;
; return(FALSE);
;
	tax
	jmp     incsp5
;
; chance = 0;
;
L064B:	dey
	sta     (sp),y
;
; res = FALSE;
;
	dey
	sta     (sp),y
;
; if (*plusses > 0) {
;
	ldy     #$04
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     #$00
	jsr     ldaidx
	sec
	sbc     #$01
	bvs     L00D3
	eor     #$80
L00D3:	bpl     L00D6
;
; chance = *plusses;
;
	ldy     #$04
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     #$00
	jsr     ldaidx
	iny
	sta     (sp),y
;
; if (randint(100) == 1)     /* very rarely allow enchantment over limit */
;
	ldx     #$00
	lda     #$64
	jsr     _randint
	cpx     #$00
	bne     L00D6
	cmp     #$01
	bne     L00D6
;
; chance = randint(chance) - 1;
;
	tay
	lda     (sp),y
	cmp     #$80
	bcc     L00DE
	dex
L00DE:	jsr     _randint
	sec
	sbc     #$01
	ldy     #$01
	sta     (sp),y
;
; if (randint(limit) > chance) {
;
L00D6:	ldy     #$02
	ldx     #$00
	lda     (sp),y
	cmp     #$80
	bcc     L00E4
	dex
L00E4:	jsr     _randint
	jsr     pushax
	ldy     #$03
	ldx     #$00
	lda     (sp),y
	bpl     L00E5
	dex
L00E5:	jsr     tosicmp
	bmi     L00E0
	beq     L00E0
;
; *plusses += 1;
;
	ldy     #$04
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     pushax
	ldy     #$00
	jsr     ldaidx
	clc
	adc     #$01
	jsr     staspidx
;
; res = TRUE;
;
	lda     #$01
	ldy     #$00
	sta     (sp),y
;
; return(res);
;
L00E0:	ldx     #$00
	lda     (sp,x)
;
; }
;
	jmp     incsp5

.endproc

; ---------------------------------------------------------------
; void __near__ __fastcall__ scroll1_invcopy (__near__ struct inven_type*, unsigned int)
; ---------------------------------------------------------------

.segment	"SCROLL1BANK"

.proc	_scroll1_invcopy: near

.segment	"SCROLL1BANK"

;
; {
;
	jsr     pushax
;
; register treasure_type *from;
;
	lda     regbank+4
	ldx     regbank+5
	jsr     pushax
;
; vbxe_bank(VBXE_OBJBANK);                                      // bank in the object list to vbxe memory
;
	lda     #$88
	jsr     _vbxe_bank
;
; from = &object_list[from_index];
;
	ldy     #$05
	jsr     pushwysp
	lda     #$19
	jsr     tosmula0
	clc
	adc     #<(_object_list)
	sta     regbank+4
	txa
	adc     #>(_object_list)
	sta     regbank+4+1
;
; to->index     = from_index;
;
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	dey
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     #$00
	sta     (ptr1),y
	iny
	txa
	sta     (ptr1),y
;
; to->name2     = SN_NULL;
;
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     #$00
	ldy     #$02
	sta     (ptr1),y
;
; to->inscrip[0] = '\0';
;
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     #$00
	dey
	sta     (ptr1),y
;
; to->flags     = from->flags;
;
	ldy     #$07
	jsr     pushwysp
	lda     regbank+4
	ldx     regbank+4+1
	ldy     #$05
	jsr     ldeaxidx
	ldy     #$10
	jsr     steaxspidx
;
; to->tval      = from->tval;
;
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$06
	lda     (regbank+4),y
	ldy     #$14
	sta     (ptr1),y
;
; to->tchar     = from->tchar;
;
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$07
	lda     (regbank+4),y
	ldy     #$15
	sta     (ptr1),y
;
; to->p1        = from->p1;
;
	ldy     #$07
	jsr     pushwysp
	ldy     #$09
	lda     (regbank+4),y
	tax
	dey
	lda     (regbank+4),y
	ldy     #$16
	jsr     staxspidx
;
; to->cost      = from->cost;
;
	ldy     #$07
	jsr     pushwysp
	lda     regbank+4
	ldx     regbank+4+1
	ldy     #$0D
	jsr     ldeaxidx
	ldy     #$18
	jsr     steaxspidx
;
; to->subval    = from->subval;
;
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0E
	lda     (regbank+4),y
	ldy     #$1C
	sta     (ptr1),y
;
; to->number    = from->number;
;
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$0F
	lda     (regbank+4),y
	ldy     #$1D
	sta     (ptr1),y
;
; to->weight    = from->weight;
;
	ldy     #$07
	jsr     pushwysp
	ldy     #$11
	lda     (regbank+4),y
	tax
	dey
	lda     (regbank+4),y
	ldy     #$1E
	jsr     staxspidx
;
; to->tohit     = from->tohit;
;
	ldy     #$07
	jsr     pushwysp
	lda     regbank+4
	ldx     regbank+4+1
	ldy     #$12
	jsr     ldaidx
	ldy     #$20
	jsr     staspidx
;
; to->todam     = from->todam;
;
	ldy     #$07
	jsr     pushwysp
	lda     regbank+4
	ldx     regbank+4+1
	ldy     #$13
	jsr     ldaidx
	ldy     #$21
	jsr     staspidx
;
; to->ac        = from->ac;
;
	ldy     #$07
	jsr     pushwysp
	lda     regbank+4
	ldx     regbank+4+1
	ldy     #$14
	jsr     ldaidx
	ldy     #$22
	jsr     staspidx
;
; to->toac      = from->toac;
;
	ldy     #$07
	jsr     pushwysp
	lda     regbank+4
	ldx     regbank+4+1
	ldy     #$15
	jsr     ldaidx
	ldy     #$23
	jsr     staspidx
;
; to->damage[0] = from->damage[0];
;
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$16
	lda     (regbank+4),y
	ldy     #$24
	sta     (ptr1),y
;
; to->damage[1] = from->damage[1];
;
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$17
	lda     (regbank+4),y
	ldy     #$25
	sta     (ptr1),y
;
; to->level     = from->level;
;
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$18
	lda     (regbank+4),y
	ldy     #$26
	sta     (ptr1),y
;
; to->ident     = 0;
;
	ldy     #$05
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	lda     #$00
	ldy     #$27
	sta     (ptr1),y
;
; vbxe_restore_bank();                                          // restore previous vbxe bank
;
	jsr     _vbxe_restore_bank
;
; }
;
	ldy     #$00
	lda     (sp),y
	sta     regbank+4
	iny
	lda     (sp),y
	sta     regbank+5
	jmp     incsp6

.endproc

; ---------------------------------------------------------------
; signed char __near__ __fastcall__ scroll1_object_offset (__near__ struct inven_type*)
; ---------------------------------------------------------------

.segment	"SCROLL1BANK"

.proc	_scroll1_object_offset: near

.segment	"SCROLL1BANK"

;
; {
;
	jsr     pushax
;
; switch (t_ptr->tval)
;
	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$14
	ldx     #$00
	lda     (ptr1),y
;
; }
;
	cmp     #$28
	beq     L064F
	cmp     #$2D
	beq     L0650
	cmp     #$37
	beq     L0651
	cmp     #$41
	beq     L0652
	cmp     #$46
	beq     L0653
	cmp     #$47
	beq     L0653
	cmp     #$4B
	beq     L0654
	cmp     #$4C
	beq     L0654
	cmp     #$50
	beq     L0144
	jmp     L014E
;
; case TV_AMULET:             return(0);
;
L064F:	txa
	jmp     incsp2
;
; case TV_RING:               return(1);
;
L0650:	lda     #$01
	jmp     incsp2
;
; case TV_STAFF:              return(2);
;
L0651:	lda     #$02
	jmp     incsp2
;
; case TV_WAND:               return(3);
;
L0652:	lda     #$03
	jmp     incsp2
;
; case TV_SCROLL2:            return(4);
;
L0653:	lda     #$04
	jmp     incsp2
;
; case TV_POTION2:            return(5);
;
L0654:	lda     #$05
	jmp     incsp2
;
; if ((t_ptr->subval & (ITEM_SINGLE_STACK_MIN - 1)) < MAX_MUSH)
;
L0144:	ldy     #$01
	lda     (sp),y
	sta     ptr1+1
	lda     (sp,x)
	sta     ptr1
	ldy     #$1C
	lda     (ptr1),y
	and     #$3F
	cmp     #$16
	bcs     L014E
;
; return(6);
;
	lda     #$06
	jmp     incsp2
;
; default:                    return(-1);
;
L014E:	dex
	txa
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ scroll1_known1_p (__near__ struct inven_type*)
; ---------------------------------------------------------------

.segment	"SCROLL1BANK"

.proc	_scroll1_known1_p: near

.segment	"SCROLL1BANK"

;
; {
;
	jsr     pushax
;
; if ((offset = scroll1_object_offset(i_ptr)) < 0)
;
	jsr     decsp3
	ldy     #$04
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _scroll1_object_offset
	ldx     #$00
	cmp     #$80
	bcc     L0157
	dex
L0157:	ldy     #$01
	jsr     staxysp
	cpx     #$80
	bcc     L0152
;
; return OD_KNOWN1;
;
	ldx     #$00
	lda     #$02
	jmp     incsp5
;
; if(i_ptr->ident & ID_STOREBOUGHT)                                                             // removed call to store_bought_p
;
L0152:	ldy     #$04
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$27
	lda     (ptr1),y
	and     #$10
	beq     L0159
;
; return OD_KNOWN1;
;
	ldx     #$00
	lda     #$02
	jmp     incsp5
;
; offset <<= 6;
;
L0159:	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     aslax4
	jsr     aslax2
	jsr     staxysp
;
; indexx = i_ptr->subval & (ITEM_SINGLE_STACK_MIN - 1);
;
	ldy     #$04
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$1C
	lda     (ptr1),y
	and     #$3F
	ldy     #$00
	sta     (sp),y
;
; return(object_ident[offset + indexx] & OD_KNOWN1);           // object ident in BSS in main ram
;
	clc
	iny
	adc     (sp),y
	sta     ptr1
	lda     #$00
	iny
	adc     (sp),y
	clc
	adc     #>(_object_ident)
	sta     ptr1+1
	ldy     #<(_object_ident)
	lda     (ptr1),y
	ldx     #$00
	and     #$02
;
; }
;
	jmp     incsp5

.endproc

; ---------------------------------------------------------------
; void __near__ __fastcall__ scroll1_sample (__near__ struct inven_type*)
; ---------------------------------------------------------------

.segment	"SCROLL1BANK"

.proc	_scroll1_sample: near

.segment	"SCROLL1BANK"

;
; {
;
	jsr     pushax
;
; if ((offset = scroll1_object_offset(i_ptr)) < 0)
;
	jsr     decsp3
	ldy     #$04
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _scroll1_object_offset
	ldx     #$00
	cmp     #$80
	bcc     L016A
	dex
L016A:	ldy     #$01
	jsr     staxysp
	cpx     #$80
;
; return;
;
	bcs     L0164
;
; offset <<= 6;
;
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     aslax4
	jsr     aslax2
	jsr     staxysp
;
; indexx = i_ptr->subval & (ITEM_SINGLE_STACK_MIN - 1);
;
	ldy     #$04
	lda     (sp),y
	sta     ptr1+1
	dey
	lda     (sp),y
	sta     ptr1
	ldy     #$1C
	lda     (ptr1),y
	and     #$3F
	ldy     #$00
	sta     (sp),y
;
; object_ident[offset + indexx] |= OD_TRIED;
;
	clc
	iny
	adc     (sp),y
	pha
	lda     #$00
	iny
	adc     (sp),y
	tax
	pla
	clc
	adc     #<(_object_ident)
	sta     ptr1
	txa
	adc     #>(_object_ident)
	sta     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	ora     #$01
	sta     (ptr1),y
;
; }
;
L0164:	jmp     incsp5

.endproc

; ---------------------------------------------------------------
; signed char __near__ __fastcall__ scroll1_bit_pos (__near__ unsigned long*)
; ---------------------------------------------------------------

.segment	"SCROLL1BANK"

.proc	_scroll1_bit_pos: near

.segment	"SCROLL1BANK"

;
; {
;
	jsr     pushax
;
; register int8u i;
;
	lda     regbank+5
	jsr     pusha
;
; int32u mask = 0x1;
;
	ldx     #$00
	lda     #$01
	jsr     push0ax
;
; for (i = 0; i < sizeof(*test)*8; ++i) {
;
	stx     regbank+5
L0655:	lda     regbank+5
	cmp     #$20
	bcs     L0176
;
; if (*test & mask) {
;
	ldy     #$06
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     ldeaxi
	jsr     pusheax
	ldy     #$07
	jsr     ldeaxysp
	jsr     tosandeax
	jsr     utsteax
	beq     L017E
;
; *test &= ~mask;
;
	ldy     #$06
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     pushax
	jsr     ldeaxi
	jsr     pusheax
	ldy     #$09
	jsr     ldeaxysp
	jsr     compleax
	jsr     tosandeax
	ldy     #$00
	jsr     steaxspidx
;
; return(i);
;
	ldx     #$00
	lda     regbank+5
	bpl     L0173
	dex
	jmp     L0173
;
; mask <<= 1;
;
L017E:	jsr     ldeax0sp
	jsr     shleax1
	jsr     steax0sp
;
; for (i = 0; i < sizeof(*test)*8; ++i) {
;
	inc     regbank+5
	jmp     L0655
;
; return(-1);
;
L0176:	ldx     #$FF
	txa
;
; }
;
L0173:	pha
	ldy     #$04
	lda     (sp),y
	sta     regbank+5
	pla
	jmp     incsp7

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ scroll1_popt (void)
; ---------------------------------------------------------------

.segment	"SCROLL1BANK"

.proc	_scroll1_popt: near

.segment	"SCROLL1BANK"

;
; if (tcptr == MAX_TALLOC)    // MAX_TALLOC is 175 -SJ
;
	lda     _tcptr+1
	bne     L018A
	lda     _tcptr
	cmp     #$AF
	bne     L018A
;
; bank_compact_objects(SCROLL1NUM);
;
	lda     #$29
	jsr     _bank_compact_objects
;
; return(++tcptr);
;
L018A:	inc     _tcptr
	bne     L0191
	inc     _tcptr+1
L0191:	lda     _tcptr
	ldx     _tcptr+1
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ trap_creation (void)
; ---------------------------------------------------------------

.segment	"SCROLL1BANK"

.proc	_trap_creation: near

.segment	"SCROLL1BANK"

;
; register cave_type *c_ptr;
;
	jsr     decsp3
	lda     regbank+4
	ldx     regbank+5
	jsr     pushax
;
; trap = TRUE;
;
	jsr     decsp1
	lda     #$01
	ldy     #$03
	sta     (sp),y
;
; for (i = char_row-1; i <= char_row+1; ++i)
;
	lda     _char_row
	sec
	sbc     #$01
	ldy     #$05
L065A:	sta     (sp),y
	lda     (sp),y
	jsr     pusha0
	lda     _char_row
	clc
	adc     #$01
	bcc     L05C1
	ldx     #$01
L05C1:	jsr     tosicmp
	beq     L065C
	jcs     L05BA
;
; for (j = char_col-1; j <= char_col+1; ++j) {
;
L065C:	lda     _char_col
	sec
	sbc     #$01
	ldy     #$04
L0659:	sta     (sp),y
	lda     (sp),y
	jsr     pusha0
	lda     _char_col
	clc
	adc     #$01
	bcc     L05CB
	ldx     #$01
L05CB:	jsr     tosicmp
	beq     L065D
	jcs     L05BB
;
; if (i == char_row && j == char_col)
;
L065D:	ldy     #$05
	lda     (sp),y
	cmp     _char_row
	bne     L05CD
	dey
	lda     (sp),y
	cmp     _char_col
	jeq     L0661
;
; vbxe_bank(VBXE_CAVBANK);
;
L05CD:	lda     #$A8
	jsr     _vbxe_bank
;
; c_ptr = CAVE_ADR(i, j);
;
	ldy     #$05
	ldx     #$00
	lda     (sp),y
	asl     a
	bcc     L065B
	inx
	clc
L065B:	adc     #<(_crow_lookup)
	sta     ptr1
	txa
	adc     #>(_crow_lookup)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     ptr1
	stx     ptr1+1
	ldy     #$04
	lda     (sp),y
	ldx     #$00
	jsr     shlax2
	clc
	adc     ptr1
	sta     regbank+4
	txa
	adc     ptr1+1
	sta     regbank+4+1
;
; if (c_ptr->fval <= MAX_CAVE_FLOOR) {
;
	ldy     #$02
	lda     (regbank+4),y
	cmp     #$05
	bcs     L05C5
;
; if (c_ptr->tptr != 0)
;
	dey
	lda     (regbank+4),y
	beq     L05DB
;
; bank_delete_object(i, j, SCROLL1NUM);
;
	jsr     decsp2
	ldy     #$07
	lda     (sp),y
	ldy     #$01
	sta     (sp),y
	ldy     #$06
	lda     (sp),y
	ldy     #$00
	sta     (sp),y
	lda     #$29
	jsr     _bank_delete_object
;
; bank_place_trap(i, j, randint(MAX_TRAP)-1, SCROLL1NUM);
;
L05DB:	jsr     decsp3
	ldy     #$08
	lda     (sp),y
	ldy     #$02
	sta     (sp),y
	ldy     #$07
	lda     (sp),y
	ldy     #$01
	sta     (sp),y
	ldx     #$00
	lda     #$12
	jsr     _randint
	sec
	sbc     #$01
	ldy     #$00
	sta     (sp),y
	lda     #$29
	jsr     _bank_place_trap
;
; tptr = c_ptr->tptr;
;
	ldy     #$01
	lda     (regbank+4),y
	dey
	sta     (sp),y
;
; vbxe_bank(VBXE_OBJBANK);
;
	lda     #$88
	jsr     _vbxe_bank
;
; t_list[tptr].p1 = 0;
;
	ldx     #$00
	lda     (sp,x)
	jsr     pusha0
	lda     #$28
	jsr     tosmula0
	clc
	adc     #<(_t_list)
	sta     ptr1
	txa
	adc     #>(_t_list)
	sta     ptr1+1
	lda     #$00
	ldy     #$16
	sta     (ptr1),y
	iny
	sta     (ptr1),y
;
; scroll1_lite_spot(i, j);
;
	ldy     #$05
	lda     (sp),y
	jsr     pusha
	ldy     #$05
	lda     (sp),y
	jsr     _scroll1_lite_spot
;
; for (j = char_col-1; j <= char_col+1; ++j) {
;
L05C5:	ldy     #$04
L0661:	clc
	lda     #$01
	adc     (sp),y
	jmp     L0659
;
; for (i = char_row-1; i <= char_row+1; ++i)
;
L05BB:	ldy     #$05
	clc
	lda     #$01
	adc     (sp),y
	jmp     L065A
;
; return(trap);
;
L05BA:	ldy     #$03
	ldx     #$00
	lda     (sp),y
;
; }
;
	pha
	ldy     #$01
	lda     (sp),y
	sta     regbank+4
	iny
	lda     (sp),y
	sta     regbank+5
	pla
	jmp     incsp6

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ __fastcall__ door_creation (void)
; ---------------------------------------------------------------

.segment	"SCROLL1BANK"

.proc	_door_creation: near

.segment	"SCROLL1BANK"

;
; register cave_type *c_ptr;
;
	jsr     decsp4
	lda     regbank+4
	ldx     regbank+5
	jsr     pushax
;
; door = FALSE;
;
	lda     #$00
	ldy     #$03
	sta     (sp),y
;
; for (i = char_row-1; i <= char_row+1; ++i)
;
	lda     _char_row
	sec
	sbc     #$01
	ldy     #$05
L0666:	sta     (sp),y
	lda     (sp),y
	jsr     pusha0
	lda     _char_row
	clc
	adc     #$01
	bcc     L05FF
	ldx     #$01
L05FF:	jsr     tosicmp
	beq     L0668
	jcs     L05F8
;
; for (j = char_col-1; j <=  char_col+1; ++j)
;
L0668:	lda     _char_col
	sec
	sbc     #$01
	ldy     #$04
L0665:	sta     (sp),y
	lda     (sp),y
	jsr     pusha0
	lda     _char_col
	clc
	adc     #$01
	bcc     L0609
	ldx     #$01
L0609:	jsr     tosicmp
	beq     L0669
	jcs     L05F9
;
; if ((i != char_row) || (j != char_col)) {
;
L0669:	ldy     #$05
	lda     (sp),y
	cmp     _char_row
	bne     L066A
	dey
	lda     (sp),y
	cmp     _char_col
	jeq     L066C
;
; vbxe_bank(VBXE_CAVBANK);
;
L066A:	lda     #$A8
	jsr     _vbxe_bank
;
; c_ptr = CAVE_ADR(i,j);
;
	ldy     #$05
	ldx     #$00
	lda     (sp),y
	asl     a
	bcc     L0667
	inx
	clc
L0667:	adc     #<(_crow_lookup)
	sta     ptr1
	txa
	adc     #>(_crow_lookup)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     ptr1
	stx     ptr1+1
	ldy     #$04
	lda     (sp),y
	ldx     #$00
	jsr     shlax2
	clc
	adc     ptr1
	sta     regbank+4
	txa
	adc     ptr1+1
	sta     regbank+4+1
;
; if (c_ptr->fval <= MAX_CAVE_FLOOR) {
;
	ldy     #$02
	lda     (regbank+4),y
	cmp     #$05
	bcs     L0603
;
; door = TRUE;
;
	lda     #$01
	iny
	sta     (sp),y
;
; if (c_ptr->tptr != 0)
;
	tay
	lda     (regbank+4),y
	beq     L061C
;
; bank_delete_object(i, j, SCROLL1NUM);
;
	jsr     decsp2
	ldy     #$07
	lda     (sp),y
	ldy     #$01
	sta     (sp),y
	ldy     #$06
	lda     (sp),y
	ldy     #$00
	sta     (sp),y
	lda     #$29
	jsr     _bank_delete_object
;
; k = scroll1_popt();
;
L061C:	jsr     _scroll1_popt
	ldy     #$02
	sta     (sp),y
;
; c_ptr->fval = BLOCKED_FLOOR;
;
	lda     #$04
	sta     (regbank+4),y
;
; c_ptr->tptr = k;
;
	lda     (sp),y
	dey
	sta     (regbank+4),y
;
; scroll1_invcopy(&t_list[k], OBJ_CLOSED_DOOR);
;
	iny
	lda     (sp),y
	jsr     pusha0
	lda     #$28
	jsr     tosmula0
	clc
	adc     #<(_t_list)
	tay
	txa
	adc     #>(_t_list)
	tax
	tya
	jsr     pushax
	ldx     #$01
	lda     #$70
	jsr     _scroll1_invcopy
;
; scroll1_lite_spot(i, j);
;
	ldy     #$05
	lda     (sp),y
	jsr     pusha
	ldy     #$05
	lda     (sp),y
	jsr     _scroll1_lite_spot
;
; for (j = char_col-1; j <=  char_col+1; ++j)
;
L0603:	ldy     #$04
L066C:	clc
	lda     #$01
	adc     (sp),y
	jmp     L0665
;
; for (i = char_row-1; i <= char_row+1; ++i)
;
L05F9:	ldy     #$05
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0666
;
; return(door);
;
L05F8:	ldy     #$03
	ldx     #$00
	lda     (sp),y
;
; }
;
	pha
	lda     (sp,x)
	sta     regbank+4
	ldy     #$01
	lda     (sp),y
	sta     regbank+5
	pla
	jmp     incsp6

.endproc

; ---------------------------------------------------------------
; void __near__ __fastcall__ read_scroll (void)
; ---------------------------------------------------------------

.segment	"SCROLL1BANK"

.proc	_read_scroll: near

.segment	"SCROLL1BANK"

;
; register int8u ident, l;
;
	ldy     #$11
	jsr     subysp
	lda     regbank+5
	jsr     pusha
	lda     regbank+4
	jsr     pusha
;
; register inven_type *i_ptr;
;
	lda     regbank+2
	ldx     regbank+3
	jsr     pushax
;
; free_turn_flag = TRUE;
;
	lda     #$01
	sta     _free_turn_flag
;
; if (py.flags.blind > 0)
;
	lda     _py+352
	beq     L0196
;
; bank_msg_print("You can't see to read the scroll.", SCROLL1NUM);
;
	lda     #<(L0199)
	ldx     #>(L0199)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; else if (scroll1_no_light())
;
	jmp     L05AD
L0196:	jsr     _scroll1_no_light
	tax
	beq     L067B
;
; bank_msg_print("You have no light to read by.", SCROLL1NUM);
;
	lda     #<(L01A0)
	ldx     #>(L01A0)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; else if (py.flags.confused > 0)
;
	jmp     L05AD
L067B:	lda     _py+354
	beq     L067C
;
; bank_msg_print("You are too confused to read a scroll.", SCROLL1NUM);
;
	lda     #<(L01A7)
	ldx     #>(L01A7)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; else if (inven_ctr == 0)
;
	jmp     L05AD
L067C:	lda     _inven_ctr
	bne     L01AB
;
; bank_msg_print("You are not carrying anything!", SCROLL1NUM);
;
	lda     #<(L01AE)
	ldx     #>(L01AE)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; else if (!scroll1_find_range(TV_SCROLL1, TV_SCROLL2, &j, &k))
;
	jmp     L05AD
L01AB:	jsr     decsp4
	lda     #$46
	ldy     #$03
	sta     (sp),y
	lda     #$47
	dey
	sta     (sp),y
	lda     sp
	ldx     sp+1
	clc
	adc     #$14
	bcc     L01B7
	inx
L01B7:	ldy     #$00
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	lda     sp
	ldx     sp+1
	clc
	adc     #$13
	bcc     L01B9
	inx
L01B9:	jsr     _scroll1_find_range
	tax
	bne     L01B2
;
; bank_msg_print ("You are not carrying any scrolls!", SCROLL1NUM);
;
	lda     #<(L01BB)
	ldx     #>(L01BB)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; else if (bank_get_item(&item_val, "Read which scroll?", j, k, CNIL, "", SCROLL1NUM)) {
;
	jmp     L05AD
L01B2:	ldy     #$0A
	jsr     subysp
	lda     sp
	ldx     sp+1
	clc
	adc     #$18
	bcc     L01C3
	inx
L01C3:	ldy     #$08
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	lda     #<(L01C2)
	ldy     #$06
	sta     (sp),y
	iny
	lda     #>(L01C2)
	sta     (sp),y
	ldy     #$1A
	lda     (sp),y
	ldy     #$05
	sta     (sp),y
	ldy     #$19
	lda     (sp),y
	ldy     #$04
	sta     (sp),y
	lda     #$00
	ldy     #$02
	sta     (sp),y
	iny
	sta     (sp),y
	lda     #<(L01C8)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L01C8)
	sta     (sp),y
	lda     #$29
	jsr     _bank_get_item
	tax
	jeq     L05AD
;
; vbxe_bank(VBXE_OBJBANK);
;
	lda     #$88
	jsr     _vbxe_bank
;
; i_ptr = &inventory[item_val];
;
	ldy     #$0E
	lda     (sp),y
	jsr     pusha0
	lda     #$28
	jsr     tosmula0
	clc
	adc     #<(_inventory)
	sta     regbank+2
	txa
	adc     #>(_inventory)
	sta     regbank+2+1
;
; free_turn_flag = FALSE;
;
	lda     #$00
	sta     _free_turn_flag
;
; used_up = TRUE;
;
	lda     #$01
	ldy     #$04
	sta     (sp),y
;
; i = i_ptr->flags;
;
	lda     regbank+2
	ldx     regbank+2+1
	ldy     #$13
	jsr     ldeaxidx
	ldy     #$11
	jsr     steaxysp
;
; ident = FALSE;
;
	lda     #$00
	sta     regbank+5
;
; while (i != 0) {
;
	jmp     L01DA
;
; j = scroll1_bit_pos(&i) + 1;
;
L01D8:	lda     sp
	ldx     sp+1
	clc
	adc     #$11
	bcc     L01DF
	inx
L01DF:	jsr     _scroll1_bit_pos
	clc
	adc     #$01
	ldy     #$10
	sta     (sp),y
;
; if (i_ptr->tval == TV_SCROLL2)
;
	ldy     #$14
	lda     (regbank+2),y
	cmp     #$47
	bne     L01E1
;
; j += 32;
;
	ldy     #$10
	clc
	lda     #$20
	adc     (sp),y
	sta     (sp),y
;
; switch(j) {
;
L01E1:	ldy     #$10
	ldx     #$00
	lda     (sp),y
;
; }
;
	cmp     #$01
	jeq     L01E9
	cmp     #$02
	jeq     L020F
	cmp     #$03
	jeq     L0681
	cmp     #$04
	jeq     L02C1
	cmp     #$05
	jeq     L02D7
	cmp     #$06
	jeq     L02E2
	cmp     #$07
	jeq     L0688
	cmp     #$08
	jeq     L0300
	cmp     #$09
	jeq     L0307
	cmp     #$0A
	jeq     L0689
	cmp     #$0B
	jeq     L068C
	cmp     #$0C
	jeq     L068D
	cmp     #$0D
	jeq     L0333
	cmp     #$0E
	jeq     L068E
	cmp     #$0F
	jeq     L0340
	cmp     #$10
	jeq     L0345
	cmp     #$11
	jeq     L034A
	cmp     #$12
	jeq     L034F
	cmp     #$13
	jeq     L0354
	cmp     #$14
	jeq     L035D
	cmp     #$15
	jeq     L0362
	cmp     #$16
	jeq     L036E
	cmp     #$17
	jeq     L0372
	cmp     #$18
	jeq     L0377
	cmp     #$19
	jeq     L037B
	cmp     #$1A
	jeq     L0387
	cmp     #$1B
	jeq     L0390
	cmp     #$1C
	jeq     L0397
	cmp     #$1D
	jeq     L068F
	cmp     #$1E
	jeq     L03A2
	cmp     #$21
	jeq     L03A9
	cmp     #$22
	jeq     L03FD
	cmp     #$23
	jeq     L0694
	cmp     #$24
	jeq     L069A
	cmp     #$25
	jeq     L06B4
	cmp     #$26
	jeq     L06B5
	cmp     #$27
	jeq     L06B6
	cmp     #$28
	jeq     L06B7
	cmp     #$29
	jeq     L06B8
	cmp     #$2A
	jeq     L0584
	jmp     L058B
;
; i_ptr = &inventory[INVEN_WIELD];
;
L01E9:	lda     #<(_inventory+880)
	sta     regbank+2
	lda     #>(_inventory+880)
	sta     regbank+2+1
;
; if (i_ptr->tval != TV_NOTHING) {
;
	ldy     #$14
	lda     (regbank+2),y
	jeq     L06B9
;
; bank_objdes(out_val2, i_ptr, FALSE, SCROLL1NUM);
;
	jsr     decsp5
	lda     #<(_out_val2)
	ldy     #$03
	sta     (sp),y
	iny
	lda     #>(_out_val2)
	sta     (sp),y
	lda     regbank+2
	ldy     #$01
	sta     (sp),y
	iny
	lda     regbank+2+1
	sta     (sp),y
	txa
	tay
	sta     (sp),y
	lda     #$29
	jsr     _bank_objdes
;
; sprintf(out_val1, "Your %s glows faintly!", out_val2);
;
	jsr     decsp4
	lda     #<(_out_val1)
	ldy     #$02
	sta     (sp),y
	iny
	lda     #>(_out_val1)
	sta     (sp),y
	lda     #<(L01F6)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L01F6)
	sta     (sp),y
	lda     #<(_out_val2)
	ldx     #>(_out_val2)
	jsr     pushax
	ldy     #$06
	jsr     _sprintf
;
; bank_msg_print(out_val1, SCROLL1NUM);
;
	lda     #<(_out_val1)
	ldx     #>(_out_val1)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; vbxe_bank(VBXE_OBJBANK);
;
	lda     #$88
	jsr     _vbxe_bank
;
; if (scroll1_enchant(&i_ptr->tohit, 10)) {
;
	lda     regbank+2
	ldx     regbank+2+1
	clc
	adc     #$20
	bcc     L0201
	inx
L0201:	jsr     pushax
	lda     #$0A
	jsr     _scroll1_enchant
	tax
	beq     L01FE
;
; i_ptr->flags &= ~TR_CURSED;
;
	lda     regbank+2
	ldx     regbank+2+1
	jsr     pushax
	ldy     #$13
	jsr     ldeaxidx
	jsr     pusheax
	ldx     #$FF
	stx     sreg
	lda     #$7F
	sta     sreg+1
	txa
	jsr     tosandeax
	ldy     #$10
	jsr     steaxspidx
;
; bank_calc_bonuses(SCROLL1NUM);
;
	lda     #$29
	jsr     _bank_calc_bonuses
;
; else
;
	jmp     L0207
;
; bank_msg_print("The enchantment fails.", SCROLL1NUM);
;
L01FE:	lda     #<(L0209)
	ldx     #>(L0209)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; ident = TRUE;
;
L0207:	lda     #$01
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; i_ptr = &inventory[INVEN_WIELD];
;
L020F:	lda     #<(_inventory+880)
	sta     regbank+2
	lda     #>(_inventory+880)
	sta     regbank+2+1
;
; if (i_ptr->tval != TV_NOTHING) {
;
	ldy     #$14
	lda     (regbank+2),y
	jeq     L06B9
;
; bank_objdes(out_val2, i_ptr, FALSE, SCROLL1NUM);
;
	jsr     decsp5
	lda     #<(_out_val2)
	ldy     #$03
	sta     (sp),y
	iny
	lda     #>(_out_val2)
	sta     (sp),y
	lda     regbank+2
	ldy     #$01
	sta     (sp),y
	iny
	lda     regbank+2+1
	sta     (sp),y
	txa
	tay
	sta     (sp),y
	lda     #$29
	jsr     _bank_objdes
;
; sprintf(out_val1, "Your %s glows faintly!", out_val2);
;
	jsr     decsp4
	lda     #<(_out_val1)
	ldy     #$02
	sta     (sp),y
	iny
	lda     #>(_out_val1)
	sta     (sp),y
	lda     #<(L021C)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L021C)
	sta     (sp),y
	lda     #<(_out_val2)
	ldx     #>(_out_val2)
	jsr     pushax
	ldy     #$06
	jsr     _sprintf
;
; bank_msg_print(out_val1, SCROLL1NUM);
;
	lda     #<(_out_val1)
	ldx     #>(_out_val1)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; vbxe_bank(VBXE_OBJBANK);
;
	lda     #$88
	jsr     _vbxe_bank
;
; if ((i_ptr->tval >= TV_HAFTED)&&(i_ptr->tval <= TV_DIGGING))
;
	ldy     #$14
	lda     (regbank+2),y
	cmp     #$15
	bcc     L0680
	cmp     #$1A
	bcs     L0680
;
; j = i_ptr->damage[0] * i_ptr->damage[1];
;
	ldy     #$24
	lda     (regbank+2),y
	jsr     pusha0
	ldy     #$25
	lda     (regbank+2),y
	jsr     tosumula0
;
; else /* Bows' and arrows' enchantments should not be limited by their low base damages */
;
	jmp     L06C0
;
; j = 10;
;
L0680:	lda     #$0A
L06C0:	ldy     #$10
	sta     (sp),y
;
; if (scroll1_enchant(&i_ptr->todam, j)) {
;
	lda     regbank+2
	ldx     regbank+2+1
	clc
	adc     #$21
	bcc     L0236
	inx
L0236:	jsr     pushax
	ldy     #$12
	lda     (sp),y
	jsr     _scroll1_enchant
	tax
	beq     L0233
;
; i_ptr->flags &= ~TR_CURSED;
;
	lda     regbank+2
	ldx     regbank+2+1
	jsr     pushax
	ldy     #$13
	jsr     ldeaxidx
	jsr     pusheax
	ldx     #$FF
	stx     sreg
	lda     #$7F
	sta     sreg+1
	txa
	jsr     tosandeax
	ldy     #$10
	jsr     steaxspidx
;
; bank_calc_bonuses(SCROLL1NUM);
;
	lda     #$29
	jsr     _bank_calc_bonuses
;
; else
;
	jmp     L023C
;
; bank_msg_print("The enchantment fails.", SCROLL1NUM);
;
L0233:	lda     #<(L023E)
	ldx     #>(L023E)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; ident = TRUE;
;
L023C:	lda     #$01
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; k = 0;
;
L0681:	txa
	dey
	sta     (sp),y
;
; l = 0;
;
	sta     regbank+4
;
; if (inventory[INVEN_BODY].tval != TV_NOTHING)
;
	lda     _inventory+1020
	beq     L0682
;
; tmp[k++] = INVEN_BODY;
;
	lda     (sp),y
	pha
	clc
	adc     #$01
	sta     (sp),y
	pla
	clc
	adc     #$06
	bcc     L024E
	inx
	clc
L024E:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	lda     #$19
	ldy     #$00
	sta     (ptr1),y
;
; if (inventory[INVEN_ARM].tval != TV_NOTHING)
;
L0682:	lda     _inventory+1060
	beq     L0683
;
; tmp[k++] = INVEN_ARM;
;
	ldy     #$0F
	ldx     #$00
	lda     (sp),y
	pha
	clc
	adc     #$01
	sta     (sp),y
	pla
	clc
	adc     #$06
	bcc     L0255
	inx
	clc
L0255:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	lda     #$1A
	ldy     #$00
	sta     (ptr1),y
;
; if (inventory[INVEN_OUTER].tval != TV_NOTHING)
;
L0683:	lda     _inventory+1260
	beq     L0684
;
; tmp[k++] = INVEN_OUTER;
;
	ldy     #$0F
	ldx     #$00
	lda     (sp),y
	pha
	clc
	adc     #$01
	sta     (sp),y
	pla
	clc
	adc     #$06
	bcc     L025C
	inx
	clc
L025C:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	lda     #$1F
	ldy     #$00
	sta     (ptr1),y
;
; if (inventory[INVEN_HANDS].tval != TV_NOTHING)
;
L0684:	lda     _inventory+1100
	beq     L0685
;
; tmp[k++] = INVEN_HANDS;
;
	ldy     #$0F
	ldx     #$00
	lda     (sp),y
	pha
	clc
	adc     #$01
	sta     (sp),y
	pla
	clc
	adc     #$06
	bcc     L0263
	inx
	clc
L0263:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	lda     #$1B
	ldy     #$00
	sta     (ptr1),y
;
; if (inventory[INVEN_HEAD].tval != TV_NOTHING)
;
L0685:	lda     _inventory+940
	beq     L0686
;
; tmp[k++] = INVEN_HEAD;
;
	ldy     #$0F
	ldx     #$00
	lda     (sp),y
	pha
	clc
	adc     #$01
	sta     (sp),y
	pla
	clc
	adc     #$06
	bcc     L026A
	inx
	clc
L026A:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	lda     #$17
	ldy     #$00
	sta     (ptr1),y
;
; if (inventory[INVEN_FEET].tval != TV_NOTHING)
;
L0686:	lda     _inventory+1220
	beq     L026C
;
; tmp[k++] = INVEN_FEET;
;
	ldy     #$0F
	ldx     #$00
	lda     (sp),y
	pha
	clc
	adc     #$01
	sta     (sp),y
	pla
	clc
	adc     #$06
	bcc     L0271
	inx
	clc
L0271:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	lda     #$1E
	ldy     #$00
	sta     (ptr1),y
;
; if (k > 0)  l = tmp[randint(k)-1];
;
L026C:	ldy     #$0F
	lda     (sp),y
	beq     L0273
	ldx     #$00
	jsr     _randint
	sec
	sbc     #$01
	bcs     L0279
	dex
L0279:	clc
	adc     #$06
	bcc     L027A
	inx
	clc
L027A:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sta     regbank+4
;
; if (TR_CURSED & inventory[INVEN_BODY].flags)
;
L0273:	lda     _inventory+1016+3
	sta     sreg+1
	lda     _inventory+1016+2
	sta     sreg
	ldx     _inventory+1016+1
	lda     _inventory+1016
	jsr     pusheax
	ldx     #$00
	stx     sreg
	lda     #$80
	sta     sreg+1
	txa
	jsr     tosandeax
	jsr     utsteax
	beq     L027B
;
; l = INVEN_BODY;
;
	lda     #$19
;
; else if (TR_CURSED & inventory[INVEN_ARM].flags)
;
	jmp     L0670
L027B:	lda     _inventory+1056+3
	sta     sreg+1
	lda     _inventory+1056+2
	sta     sreg
	ldx     _inventory+1056+1
	lda     _inventory+1056
	jsr     pusheax
	ldx     #$00
	stx     sreg
	lda     #$80
	sta     sreg+1
	txa
	jsr     tosandeax
	jsr     utsteax
	beq     L0281
;
; l = INVEN_ARM;
;
	lda     #$1A
;
; else if (TR_CURSED & inventory[INVEN_OUTER].flags)
;
	jmp     L0670
L0281:	lda     _inventory+1256+3
	sta     sreg+1
	lda     _inventory+1256+2
	sta     sreg
	ldx     _inventory+1256+1
	lda     _inventory+1256
	jsr     pusheax
	ldx     #$00
	stx     sreg
	lda     #$80
	sta     sreg+1
	txa
	jsr     tosandeax
	jsr     utsteax
	beq     L0287
;
; l = INVEN_OUTER;
;
	lda     #$1F
;
; else if (TR_CURSED & inventory[INVEN_HEAD].flags)
;
	jmp     L0670
L0287:	lda     _inventory+936+3
	sta     sreg+1
	lda     _inventory+936+2
	sta     sreg
	ldx     _inventory+936+1
	lda     _inventory+936
	jsr     pusheax
	ldx     #$00
	stx     sreg
	lda     #$80
	sta     sreg+1
	txa
	jsr     tosandeax
	jsr     utsteax
	beq     L028D
;
; l = INVEN_HEAD;
;
	lda     #$17
;
; else if (TR_CURSED & inventory[INVEN_HANDS].flags)
;
	jmp     L0670
L028D:	lda     _inventory+1096+3
	sta     sreg+1
	lda     _inventory+1096+2
	sta     sreg
	ldx     _inventory+1096+1
	lda     _inventory+1096
	jsr     pusheax
	ldx     #$00
	stx     sreg
	lda     #$80
	sta     sreg+1
	txa
	jsr     tosandeax
	jsr     utsteax
	beq     L0293
;
; l = INVEN_HANDS;
;
	lda     #$1B
;
; else if (TR_CURSED & inventory[INVEN_FEET].flags)
;
	jmp     L0670
L0293:	lda     _inventory+1216+3
	sta     sreg+1
	lda     _inventory+1216+2
	sta     sreg
	ldx     _inventory+1216+1
	lda     _inventory+1216
	jsr     pusheax
	ldx     #$00
	stx     sreg
	lda     #$80
	sta     sreg+1
	txa
	jsr     tosandeax
	jsr     utsteax
	beq     L0299
;
; l = INVEN_FEET;
;
	lda     #$1E
L0670:	sta     regbank+4
;
; if (l > 0) {
;
L0299:	lda     regbank+4
	jeq     L01DA
;
; i_ptr = &inventory[l];
;
	lda     regbank+4
	jsr     pusha0
	lda     #$28
	jsr     tosmula0
	clc
	adc     #<(_inventory)
	sta     regbank+2
	txa
	adc     #>(_inventory)
	sta     regbank+2+1
;
; bank_objdes(out_val2, i_ptr, FALSE, SCROLL1NUM);
;
	jsr     decsp5
	lda     #<(_out_val2)
	ldy     #$03
	sta     (sp),y
	iny
	lda     #>(_out_val2)
	sta     (sp),y
	lda     regbank+2
	ldy     #$01
	sta     (sp),y
	iny
	lda     regbank+2+1
	sta     (sp),y
	lda     #$00
	tay
	sta     (sp),y
	lda     #$29
	jsr     _bank_objdes
;
; sprintf(out_val1, "Your %s glows faintly!", out_val2);
;
	jsr     decsp4
	lda     #<(_out_val1)
	ldy     #$02
	sta     (sp),y
	iny
	lda     #>(_out_val1)
	sta     (sp),y
	lda     #<(L02AA)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L02AA)
	sta     (sp),y
	lda     #<(_out_val2)
	ldx     #>(_out_val2)
	jsr     pushax
	ldy     #$06
	jsr     _sprintf
;
; bank_msg_print(out_val1, SCROLL1NUM);
;
	lda     #<(_out_val1)
	ldx     #>(_out_val1)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; if (scroll1_enchant(&i_ptr->toac, 10)) {
;
	lda     regbank+2
	ldx     regbank+2+1
	clc
	adc     #$23
	bcc     L02B3
	inx
L02B3:	jsr     pushax
	lda     #$0A
	jsr     _scroll1_enchant
	tax
	beq     L02B0
;
; i_ptr->flags &= ~TR_CURSED;
;
	lda     regbank+2
	ldx     regbank+2+1
	jsr     pushax
	ldy     #$13
	jsr     ldeaxidx
	jsr     pusheax
	ldx     #$FF
	stx     sreg
	lda     #$7F
	sta     sreg+1
	txa
	jsr     tosandeax
	ldy     #$10
	jsr     steaxspidx
;
; bank_calc_bonuses(SCROLL1NUM);
;
	lda     #$29
	jsr     _bank_calc_bonuses
;
; else
;
	jmp     L02B9
;
; bank_msg_print("The enchantment fails.", SCROLL1NUM);
;
L02B0:	lda     #<(L02BB)
	ldx     #>(L02BB)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; ident = TRUE;
;
L02B9:	lda     #$01
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; bank_msg_print("This is an identify scroll.", SCROLL1NUM);
;
L02C1:	lda     #<(L02C3)
	ldx     #>(L02C3)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; ident = TRUE;
;
	lda     #$01
	sta     regbank+5
;
; used_up = bank_ident_spell(SCROLL1NUM);
;
	lda     #$29
	jsr     _bank_ident_spell
	ldy     #$04
	sta     (sp),y
;
; vbxe_bank(VBXE_OBJBANK);             // CHECK: might still be in bank
;
	lda     #$88
	jsr     _vbxe_bank
;
; while (i_ptr->tval != TV_SCROLL1 || i_ptr->flags != 0x00000008) {
;
	jmp     L02CF
;
; --item_val;
;
L02CD:	ldy     #$0E
	lda     (sp),y
	sec
	sbc     #$01
	sta     (sp),y
;
; i_ptr = &inventory[item_val];
;
	lda     (sp),y
	jsr     pusha0
	lda     #$28
	jsr     tosmula0
	clc
	adc     #<(_inventory)
	sta     regbank+2
	txa
	adc     #>(_inventory)
	sta     regbank+2+1
;
; while (i_ptr->tval != TV_SCROLL1 || i_ptr->flags != 0x00000008) {
;
L02CF:	ldy     #$14
	lda     (regbank+2),y
	cmp     #$46
	bne     L02CD
	lda     regbank+2
	ldx     regbank+2+1
	dey
	jsr     ldeaxidx
	jsr     pusheax
	ldx     #$00
	stx     sreg
	stx     sreg+1
	lda     #$08
	jsr     tosneeax
	bne     L02CD
	jmp     L01DA
;
; if (bank_remove_curse(SCROLL1NUM)) {
;
L02D7:	lda     #$29
	jsr     _bank_remove_curse
	tax
	jeq     L01DA
;
; bank_msg_print("You feel as if someone is watching over you.", SCROLL1NUM);
;
	lda     #<(L02DC)
	ldx     #>(L02DC)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; ident = TRUE;
;
	lda     #$01
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; ident = bank_light_area(char_row, char_col, SCROLL1NUM);
;
L02E2:	jsr     decsp2
	lda     _char_row
	ldy     #$01
	sta     (sp),y
	lda     _char_col
	dey
	sta     (sp),y
	lda     #$29
	jsr     _bank_light_area
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; for (k = 0; k < randint(3); ++k) {
;
L0688:	txa
	dey
L0671:	sta     (sp),y
	lda     (sp),y
	jsr     pusha0
	lda     #$03
	jsr     _randint
	jsr     tosicmp
	jcs     L01DA
;
; y = char_row;
;
	lda     _char_row
	ldy     #$0D
	sta     (sp),y
;
; x = char_col;
;
	lda     _char_col
	dey
	sta     (sp),y
;
; ident |= bank_summon_monster(&y, &x, FALSE, SCROLL1NUM);
;
	lda     regbank+5
	jsr     pusha0
	jsr     decsp5
	lda     sp
	ldx     sp+1
	clc
	adc     #$14
	bcc     L02FA
	inx
L02FA:	ldy     #$03
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	lda     sp
	ldx     sp+1
	clc
	adc     #$13
	bcc     L02FC
	inx
L02FC:	ldy     #$01
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	lda     #$00
	tay
	sta     (sp),y
	lda     #$29
	jsr     _bank_summon_monster
	jsr     tosorax
	sta     regbank+5
;
; for (k = 0; k < randint(3); ++k) {
;
	ldy     #$0F
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0671
;
; bank_teleport(10, SCROLL1NUM);
;
L0300:	lda     #$0A
	jsr     pusha
	lda     #$29
	jsr     _bank_teleport
;
; ident = TRUE;
;
	lda     #$01
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; bank_teleport(100, SCROLL1NUM);
;
L0307:	lda     #$64
	jsr     pusha
	lda     #$29
	jsr     _bank_teleport
;
; ident = TRUE;
;
	lda     #$01
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; dun_level += (-3) + 2*randint(2);    // might make dun_level wrap around -SJ
;
L0689:	lda     #$02
	jsr     _randint
	stx     tmp1
	asl     a
	rol     tmp1
	clc
	adc     #$FD
	pha
	lda     tmp1
	adc     #$FF
	pla
	clc
	adc     _dun_level
	sta     _dun_level
;
; if (dun_level < 1)
;
	lda     _dun_level
	bne     L068A
;
; dun_level = 1;
;
	lda     #$01
;
; else if (dun_level > 200)      // check for wrap around -SJ
;
	jmp     L0672
L068A:	lda     _dun_level
	cmp     #$C9
	bcc     L068B
;
; dun_level = 99;
;
	lda     #$63
L0672:	sta     _dun_level
;
; new_level_flag = TRUE;
;
L068B:	lda     #$01
	sta     _new_level_flag
;
; ident = TRUE;
;
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; if (py.flags.confuse_monster == 0) {
;
L068C:	lda     _py+394
	jne     L01DA
;
; bank_msg_print("Your hands begin to glow.", SCROLL1NUM);
;
	lda     #<(L0325)
	ldx     #>(L0325)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; py.flags.confuse_monster = TRUE;
;
	lda     #$01
	sta     _py+394
;
; ident = TRUE;
;
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; ident = TRUE;
;
L068D:	lda     #$01
	sta     regbank+5
;
; bank_map_area(SCROLL1NUM);
;
	lda     #$29
	jsr     _bank_map_area
;
; break;
;
	jmp     L01DA
;
; ident = bank_sleep_monsters1(char_row, char_col, SCROLL1NUM);
;
L0333:	jsr     decsp2
	lda     _char_row
	ldy     #$01
	sta     (sp),y
	lda     _char_col
	dey
	sta     (sp),y
	lda     #$29
	jsr     _bank_sleep_monsters1
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; ident = TRUE;
;
L068E:	lda     #$01
	sta     regbank+5
;
; bank_warding_glyph(SCROLL1NUM);
;
	lda     #$29
	jsr     _bank_warding_glyph
;
; break;
;
	jmp     L01DA
;
; ident = bank_detect_treasure(SCROLL1NUM);
;
L0340:	lda     #$29
	jsr     _bank_detect_treasure
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; ident = bank_detect_object(SCROLL1NUM);
;
L0345:	lda     #$29
	jsr     _bank_detect_object
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; ident = bank_detect_trap(SCROLL1NUM);
;
L034A:	lda     #$29
	jsr     _bank_detect_trap
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; ident = bank_detect_sdoor(SCROLL1NUM);
;
L034F:	lda     #$29
	jsr     _bank_detect_sdoor
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; bank_msg_print("This is a mass genocide scroll.", SCROLL1NUM);
;
L0354:	lda     #<(L0356)
	ldx     #>(L0356)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; ident = bank_mass_genocide(SCROLL1NUM);
;
	lda     #$29
	jsr     _bank_mass_genocide
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; ident = bank_detect_invisible(SCROLL1NUM);
;
L035D:	lda     #$29
	jsr     _bank_detect_invisible
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; ident = bank_aggravate_monster(20, SCROLL1NUM);
;
L0362:	lda     #$14
	jsr     pusha
	lda     #$29
	jsr     _bank_aggravate_monster
	sta     regbank+5
;
; if (ident)
;
	lda     regbank+5
	jeq     L01DA
;
; bank_msg_print("There is a high pitched humming noise.", SCROLL1NUM);
;
	lda     #<(L036A)
	ldx     #>(L036A)
;
; break;
;
	jmp     L06C3
;
; ident = trap_creation();
;
L036E:	jsr     _trap_creation
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; ident = bank_td_destroy(SCROLL1NUM);
;
L0372:	lda     #$29
	jsr     _bank_td_destroy
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; ident = door_creation();
;
L0377:	jsr     _door_creation
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; bank_msg_print("This is a Recharge-Item scroll.", SCROLL1NUM);
;
L037B:	lda     #<(L037D)
	ldx     #>(L037D)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; ident = TRUE;
;
	lda     #$01
	sta     regbank+5
;
; used_up = bank_recharge(60, SCROLL1NUM);
;
	lda     #$3C
	jsr     pusha
	lda     #$29
	jsr     _bank_recharge
	ldy     #$04
	sta     (sp),y
;
; break;
;
	jmp     L01DA
;
; bank_msg_print("This is a genocide scroll.", SCROLL1NUM);
;
L0387:	lda     #<(L0389)
	ldx     #>(L0389)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; ident = bank_genocide(SCROLL1NUM);
;
	lda     #$29
	jsr     _bank_genocide
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; ident = bank_unlight_area(char_row, char_col, SCROLL1NUM);
;
L0390:	jsr     decsp2
	lda     _char_row
	ldy     #$01
	sta     (sp),y
	lda     _char_col
	dey
	sta     (sp),y
	lda     #$29
	jsr     _bank_unlight_area
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; ident = bank_protect_evil(SCROLL1NUM);
;
L0397:	lda     #$29
	jsr     _bank_protect_evil
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; ident = TRUE;
;
L068F:	lda     #$01
	sta     regbank+5
;
; bank_create_food(SCROLL1NUM);
;
	lda     #$29
	jsr     _bank_create_food
;
; break;
;
	jmp     L01DA
;
; ident = bank_dispel_creature(CD_UNDEAD, 60, SCROLL1NUM);
;
L03A2:	jsr     decsp2
	lda     #$08
	ldy     #$01
	sta     (sp),y
	lda     #$3C
	dey
	sta     (sp),y
	lda     #$29
	jsr     _bank_dispel_creature
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; i_ptr = &inventory[INVEN_WIELD];
;
L03A9:	lda     #<(_inventory+880)
	sta     regbank+2
	lda     #>(_inventory+880)
	sta     regbank+2+1
;
; if (i_ptr->tval != TV_NOTHING) {
;
	ldy     #$14
	lda     (regbank+2),y
	jeq     L06B9
;
; bank_objdes(out_val2, i_ptr, FALSE, SCROLL1NUM);
;
	jsr     decsp5
	lda     #<(_out_val2)
	ldy     #$03
	sta     (sp),y
	iny
	lda     #>(_out_val2)
	sta     (sp),y
	lda     regbank+2
	ldy     #$01
	sta     (sp),y
	iny
	lda     regbank+2+1
	sta     (sp),y
	txa
	tay
	sta     (sp),y
	lda     #$29
	jsr     _bank_objdes
;
; sprintf(out_val1, "Your %s glows brightly!", out_val2);
;
	jsr     decsp4
	lda     #<(_out_val1)
	ldy     #$02
	sta     (sp),y
	iny
	lda     #>(_out_val1)
	sta     (sp),y
	lda     #<(L03B6)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L03B6)
	sta     (sp),y
	lda     #<(_out_val2)
	ldx     #>(_out_val2)
	jsr     pushax
	ldy     #$06
	jsr     _sprintf
;
; bank_msg_print(out_val1, SCROLL1NUM);
;
	lda     #<(_out_val1)
	ldx     #>(_out_val1)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; flag = FALSE;
;
	lda     #$00
	ldy     #$05
	sta     (sp),y
;
; vbxe_bank(VBXE_OBJBANK);
;
	lda     #$88
	jsr     _vbxe_bank
;
; for (k = 0; k < randint(2); ++k)
;
	lda     #$00
	ldy     #$0F
L0674:	sta     (sp),y
	lda     (sp),y
	jsr     pusha0
	lda     #$02
	jsr     _randint
	jsr     tosicmp
	bcs     L03C1
;
; if (scroll1_enchant(&i_ptr->tohit, 10))
;
	lda     regbank+2
	ldx     regbank+2+1
	clc
	adc     #$20
	bcc     L03CC
	inx
L03CC:	jsr     pushax
	lda     #$0A
	jsr     _scroll1_enchant
	tax
	beq     L03C2
;
; flag = TRUE;
;
	lda     #$01
	ldy     #$05
	sta     (sp),y
;
; for (k = 0; k < randint(2); ++k)
;
L03C2:	ldy     #$0F
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0674
;
; if ((i_ptr->tval >= TV_HAFTED)&&(i_ptr->tval <= TV_DIGGING))
;
L03C1:	ldy     #$14
	lda     (regbank+2),y
	cmp     #$15
	bcc     L0693
	cmp     #$1A
	bcs     L0693
;
; j = i_ptr->damage[0] * i_ptr->damage[1];
;
	ldy     #$24
	lda     (regbank+2),y
	jsr     pusha0
	ldy     #$25
	lda     (regbank+2),y
	jsr     tosumula0
;
; else /* Bows' and arrows' enchantments should not be limited by their low base damages */
;
	jmp     L06C2
;
; j = 10;
;
L0693:	lda     #$0A
L06C2:	ldy     #$10
	sta     (sp),y
;
; for (k = 0; k < randint(2); ++k)
;
	lda     #$00
	dey
L0676:	sta     (sp),y
	lda     (sp),y
	jsr     pusha0
	lda     #$02
	jsr     _randint
	jsr     tosicmp
	bcs     L03E0
;
; if (scroll1_enchant(&i_ptr->todam, j))
;
	lda     regbank+2
	ldx     regbank+2+1
	clc
	adc     #$21
	bcc     L03EB
	inx
L03EB:	jsr     pushax
	ldy     #$12
	lda     (sp),y
	jsr     _scroll1_enchant
	tax
	beq     L03E1
;
; flag = TRUE;
;
	lda     #$01
	ldy     #$05
	sta     (sp),y
;
; for (k = 0; k < randint(2); ++k)
;
L03E1:	ldy     #$0F
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0676
;
; if (flag) {
;
L03E0:	ldy     #$05
	lda     (sp),y
	beq     L03EF
;
; i_ptr->flags &= ~TR_CURSED;
;
	lda     regbank+2
	ldx     regbank+2+1
	jsr     pushax
	ldy     #$13
	jsr     ldeaxidx
	jsr     pusheax
	ldx     #$FF
	stx     sreg
	lda     #$7F
	sta     sreg+1
	txa
	jsr     tosandeax
	ldy     #$10
	jsr     steaxspidx
;
; bank_calc_bonuses(SCROLL1NUM);
;
	lda     #$29
	jsr     _bank_calc_bonuses
;
; else
;
	jmp     L03F5
;
; bank_msg_print("The enchantment fails.", SCROLL1NUM);
;
L03EF:	lda     #<(L03F7)
	ldx     #>(L03F7)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; ident = TRUE;
;
L03F5:	lda     #$01
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; i_ptr = &inventory[INVEN_WIELD];
;
L03FD:	lda     #<(_inventory+880)
	sta     regbank+2
	lda     #>(_inventory+880)
	sta     regbank+2+1
;
; if (i_ptr->tval != TV_NOTHING) {
;
	ldy     #$14
	lda     (regbank+2),y
	jeq     L06B9
;
; bank_objdes(out_val2, i_ptr, FALSE, SCROLL1NUM);
;
	jsr     decsp5
	lda     #<(_out_val2)
	ldy     #$03
	sta     (sp),y
	iny
	lda     #>(_out_val2)
	sta     (sp),y
	lda     regbank+2
	ldy     #$01
	sta     (sp),y
	iny
	lda     regbank+2+1
	sta     (sp),y
	txa
	tay
	sta     (sp),y
	lda     #$29
	jsr     _bank_objdes
;
; sprintf(out_val1,"Your %s glows black, fades.", out_val2);
;
	jsr     decsp4
	lda     #<(_out_val1)
	ldy     #$02
	sta     (sp),y
	iny
	lda     #>(_out_val1)
	sta     (sp),y
	lda     #<(L040A)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L040A)
	sta     (sp),y
	lda     #<(_out_val2)
	ldx     #>(_out_val2)
	jsr     pushax
	ldy     #$06
	jsr     _sprintf
;
; bank_msg_print(out_val1, SCROLL1NUM);
;
	lda     #<(_out_val1)
	ldx     #>(_out_val1)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; vbxe_bank(VBXE_OBJBANK);
;
	lda     #$88
	jsr     _vbxe_bank
;
; i_ptr->name2 = SN_NULL;      // unmagic_name code in-line -SJ
;
	lda     #$00
	ldy     #$02
	sta     (regbank+2),y
;
; i_ptr->tohit = -randint(5) - randint(5);
;
	lda     regbank+2
	ldx     regbank+2+1
	jsr     pushax
	ldx     #$00
	lda     #$05
	jsr     _randint
	jsr     negax
	jsr     pushax
	ldx     #$00
	lda     #$05
	jsr     _randint
	jsr     tossubax
	ldy     #$20
	jsr     staspidx
;
; i_ptr->todam = -randint(5) - randint(5);
;
	lda     regbank+2
	ldx     regbank+2+1
	jsr     pushax
	ldx     #$00
	lda     #$05
	jsr     _randint
	jsr     negax
	jsr     pushax
	ldx     #$00
	lda     #$05
	jsr     _randint
	jsr     tossubax
	ldy     #$21
	jsr     staspidx
;
; bank_py_bonuses(i_ptr, -1, SCROLL1NUM);
;
	jsr     decsp3
	lda     regbank+2
	ldy     #$01
	sta     (sp),y
	iny
	lda     regbank+2+1
	sta     (sp),y
	lda     #$FF
	ldy     #$00
	sta     (sp),y
	lda     #$29
	jsr     _bank_py_bonuses
;
; i_ptr->flags = TR_CURSED;
;
	lda     regbank+2
	ldx     regbank+2+1
	jsr     pushax
	ldx     #$00
	stx     sreg
	lda     #$80
	sta     sreg+1
	txa
	ldy     #$10
	jsr     steaxspidx
;
; bank_calc_bonuses(SCROLL1NUM);
;
	lda     #$29
	jsr     _bank_calc_bonuses
;
; ident = TRUE;
;
	lda     #$01
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; k = 0;
;
L0694:	txa
	dey
	sta     (sp),y
;
; l = 0;
;
	sta     regbank+4
;
; if (inventory[INVEN_BODY].tval != TV_NOTHING)
;
	lda     _inventory+1020
	beq     L0695
;
; tmp[k++] = INVEN_BODY;
;
	lda     (sp),y
	pha
	clc
	adc     #$01
	sta     (sp),y
	pla
	clc
	adc     #$06
	bcc     L0431
	inx
	clc
L0431:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	lda     #$19
	ldy     #$00
	sta     (ptr1),y
;
; if (inventory[INVEN_ARM].tval != TV_NOTHING)
;
L0695:	lda     _inventory+1060
	beq     L0696
;
; tmp[k++] = INVEN_ARM;
;
	ldy     #$0F
	ldx     #$00
	lda     (sp),y
	pha
	clc
	adc     #$01
	sta     (sp),y
	pla
	clc
	adc     #$06
	bcc     L0438
	inx
	clc
L0438:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	lda     #$1A
	ldy     #$00
	sta     (ptr1),y
;
; if (inventory[INVEN_OUTER].tval != TV_NOTHING)
;
L0696:	lda     _inventory+1260
	beq     L0697
;
; tmp[k++] = INVEN_OUTER;
;
	ldy     #$0F
	ldx     #$00
	lda     (sp),y
	pha
	clc
	adc     #$01
	sta     (sp),y
	pla
	clc
	adc     #$06
	bcc     L043F
	inx
	clc
L043F:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	lda     #$1F
	ldy     #$00
	sta     (ptr1),y
;
; if (inventory[INVEN_HANDS].tval != TV_NOTHING)
;
L0697:	lda     _inventory+1100
	beq     L0698
;
; tmp[k++] = INVEN_HANDS;
;
	ldy     #$0F
	ldx     #$00
	lda     (sp),y
	pha
	clc
	adc     #$01
	sta     (sp),y
	pla
	clc
	adc     #$06
	bcc     L0446
	inx
	clc
L0446:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	lda     #$1B
	ldy     #$00
	sta     (ptr1),y
;
; if (inventory[INVEN_HEAD].tval != TV_NOTHING)
;
L0698:	lda     _inventory+940
	beq     L0699
;
; tmp[k++] = INVEN_HEAD;
;
	ldy     #$0F
	ldx     #$00
	lda     (sp),y
	pha
	clc
	adc     #$01
	sta     (sp),y
	pla
	clc
	adc     #$06
	bcc     L044D
	inx
	clc
L044D:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	lda     #$17
	ldy     #$00
	sta     (ptr1),y
;
; if (inventory[INVEN_FEET].tval != TV_NOTHING)
;
L0699:	lda     _inventory+1220
	beq     L044F
;
; tmp[k++] = INVEN_FEET;
;
	ldy     #$0F
	ldx     #$00
	lda     (sp),y
	pha
	clc
	adc     #$01
	sta     (sp),y
	pla
	clc
	adc     #$06
	bcc     L0454
	inx
	clc
L0454:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	lda     #$1E
	ldy     #$00
	sta     (ptr1),y
;
; if (k > 0) l = tmp[randint(k)-1];
;
L044F:	ldy     #$0F
	lda     (sp),y
	beq     L0456
	ldx     #$00
	jsr     _randint
	sec
	sbc     #$01
	bcs     L045C
	dex
L045C:	clc
	adc     #$06
	bcc     L045D
	inx
	clc
L045D:	adc     sp
	sta     ptr1
	txa
	adc     sp+1
	sta     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sta     regbank+4
;
; if (TR_CURSED & inventory[INVEN_BODY].flags)
;
L0456:	lda     _inventory+1016+3
	sta     sreg+1
	lda     _inventory+1016+2
	sta     sreg
	ldx     _inventory+1016+1
	lda     _inventory+1016
	jsr     pusheax
	ldx     #$00
	stx     sreg
	lda     #$80
	sta     sreg+1
	txa
	jsr     tosandeax
	jsr     utsteax
	beq     L045E
;
; l = INVEN_BODY;
;
	lda     #$19
;
; else if (TR_CURSED & inventory[INVEN_ARM].flags)
;
	jmp     L0677
L045E:	lda     _inventory+1056+3
	sta     sreg+1
	lda     _inventory+1056+2
	sta     sreg
	ldx     _inventory+1056+1
	lda     _inventory+1056
	jsr     pusheax
	ldx     #$00
	stx     sreg
	lda     #$80
	sta     sreg+1
	txa
	jsr     tosandeax
	jsr     utsteax
	beq     L0464
;
; l = INVEN_ARM;
;
	lda     #$1A
;
; else if (TR_CURSED & inventory[INVEN_OUTER].flags)
;
	jmp     L0677
L0464:	lda     _inventory+1256+3
	sta     sreg+1
	lda     _inventory+1256+2
	sta     sreg
	ldx     _inventory+1256+1
	lda     _inventory+1256
	jsr     pusheax
	ldx     #$00
	stx     sreg
	lda     #$80
	sta     sreg+1
	txa
	jsr     tosandeax
	jsr     utsteax
	beq     L046A
;
; l = INVEN_OUTER;
;
	lda     #$1F
;
; else if (TR_CURSED & inventory[INVEN_HEAD].flags)
;
	jmp     L0677
L046A:	lda     _inventory+936+3
	sta     sreg+1
	lda     _inventory+936+2
	sta     sreg
	ldx     _inventory+936+1
	lda     _inventory+936
	jsr     pusheax
	ldx     #$00
	stx     sreg
	lda     #$80
	sta     sreg+1
	txa
	jsr     tosandeax
	jsr     utsteax
	beq     L0470
;
; l = INVEN_HEAD;
;
	lda     #$17
;
; else if (TR_CURSED & inventory[INVEN_HANDS].flags)
;
	jmp     L0677
L0470:	lda     _inventory+1096+3
	sta     sreg+1
	lda     _inventory+1096+2
	sta     sreg
	ldx     _inventory+1096+1
	lda     _inventory+1096
	jsr     pusheax
	ldx     #$00
	stx     sreg
	lda     #$80
	sta     sreg+1
	txa
	jsr     tosandeax
	jsr     utsteax
	beq     L0476
;
; l = INVEN_HANDS;
;
	lda     #$1B
;
; else if (TR_CURSED & inventory[INVEN_FEET].flags)
;
	jmp     L0677
L0476:	lda     _inventory+1216+3
	sta     sreg+1
	lda     _inventory+1216+2
	sta     sreg
	ldx     _inventory+1216+1
	lda     _inventory+1216
	jsr     pusheax
	ldx     #$00
	stx     sreg
	lda     #$80
	sta     sreg+1
	txa
	jsr     tosandeax
	jsr     utsteax
	beq     L047C
;
; l = INVEN_FEET;
;
	lda     #$1E
L0677:	sta     regbank+4
;
; if (l > 0) {
;
L047C:	lda     regbank+4
	jeq     L01DA
;
; i_ptr = &inventory[l];
;
	lda     regbank+4
	jsr     pusha0
	lda     #$28
	jsr     tosmula0
	clc
	adc     #<(_inventory)
	sta     regbank+2
	txa
	adc     #>(_inventory)
	sta     regbank+2+1
;
; bank_objdes(out_val2, i_ptr, FALSE, SCROLL1NUM);
;
	jsr     decsp5
	lda     #<(_out_val2)
	ldy     #$03
	sta     (sp),y
	iny
	lda     #>(_out_val2)
	sta     (sp),y
	lda     regbank+2
	ldy     #$01
	sta     (sp),y
	iny
	lda     regbank+2+1
	sta     (sp),y
	lda     #$00
	tay
	sta     (sp),y
	lda     #$29
	jsr     _bank_objdes
;
; sprintf(out_val1,"Your %s glows brightly!", out_val2);
;
	jsr     decsp4
	lda     #<(_out_val1)
	ldy     #$02
	sta     (sp),y
	iny
	lda     #>(_out_val1)
	sta     (sp),y
	lda     #<(L048D)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L048D)
	sta     (sp),y
	lda     #<(_out_val2)
	ldx     #>(_out_val2)
	jsr     pushax
	ldy     #$06
	jsr     _sprintf
;
; bank_msg_print(out_val1, SCROLL1NUM);
;
	lda     #<(_out_val1)
	ldx     #>(_out_val1)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; flag = FALSE;
;
	lda     #$00
	ldy     #$05
	sta     (sp),y
;
; vbxe_bank(VBXE_OBJBANK);
;
	lda     #$88
	jsr     _vbxe_bank
;
; for (k = 0; k < randint(2) + 1; ++k)
;
	lda     #$00
	ldy     #$0F
L0678:	sta     (sp),y
	lda     (sp),y
	jsr     pusha0
	lda     #$02
	jsr     _randint
	clc
	adc     #$01
	bcc     L049F
	inx
L049F:	jsr     tosicmp
	bcs     L0498
;
; if (scroll1_enchant(&i_ptr->toac, 10))
;
	lda     regbank+2
	ldx     regbank+2+1
	clc
	adc     #$23
	bcc     L04A4
	inx
L04A4:	jsr     pushax
	lda     #$0A
	jsr     _scroll1_enchant
	tax
	beq     L0499
;
; flag = TRUE;
;
	lda     #$01
	ldy     #$05
	sta     (sp),y
;
; for (k = 0; k < randint(2) + 1; ++k)
;
L0499:	ldy     #$0F
	clc
	lda     #$01
	adc     (sp),y
	jmp     L0678
;
; if (flag) {
;
L0498:	ldy     #$05
	lda     (sp),y
	beq     L04A8
;
; i_ptr->flags &= ~TR_CURSED;
;
	lda     regbank+2
	ldx     regbank+2+1
	jsr     pushax
	ldy     #$13
	jsr     ldeaxidx
	jsr     pusheax
	ldx     #$FF
	stx     sreg
	lda     #$7F
	sta     sreg+1
	txa
	jsr     tosandeax
	ldy     #$10
	jsr     steaxspidx
;
; bank_calc_bonuses(SCROLL1NUM);
;
	lda     #$29
	jsr     _bank_calc_bonuses
;
; else
;
	jmp     L04AE
;
; bank_msg_print("The enchantment fails.", SCROLL1NUM);
;
L04A8:	lda     #<(L04B0)
	ldx     #>(L04B0)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; ident = TRUE;
;
L04AE:	lda     #$01
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; if ((inventory[INVEN_BODY].tval != TV_NOTHING) && (randint(4) == 1))
;
L069A:	lda     _inventory+1020
	beq     L069D
	lda     #$04
	jsr     _randint
	cpx     #$00
	bne     L069D
	cmp     #$01
	bne     L069D
;
; k = INVEN_BODY;
;
	lda     #$19
;
; else if ((inventory[INVEN_ARM].tval != TV_NOTHING) && (randint(3) ==1))
;
	jmp     L06B3
L069D:	lda     _inventory+1060
	beq     L06A0
	ldx     #$00
	lda     #$03
	jsr     _randint
	cpx     #$00
	bne     L06A0
	cmp     #$01
	bne     L06A0
;
; k = INVEN_ARM;
;
	lda     #$1A
;
; else if ((inventory[INVEN_OUTER].tval != TV_NOTHING) && (randint(3) ==1))
;
	jmp     L06B3
L06A0:	lda     _inventory+1260
	beq     L06A3
	ldx     #$00
	lda     #$03
	jsr     _randint
	cpx     #$00
	bne     L06A3
	cmp     #$01
	bne     L06A3
;
; k = INVEN_OUTER;
;
	lda     #$1F
;
; else if ((inventory[INVEN_HEAD].tval != TV_NOTHING) && (randint(3) ==1))
;
	jmp     L06B3
L06A3:	lda     _inventory+940
	beq     L06A6
	ldx     #$00
	lda     #$03
	jsr     _randint
	cpx     #$00
	bne     L06A6
	cmp     #$01
	bne     L06A6
;
; k = INVEN_HEAD;
;
	lda     #$17
;
; else if ((inventory[INVEN_HANDS].tval != TV_NOTHING) && (randint(3) ==1))
;
	jmp     L06B3
L06A6:	lda     _inventory+1100
	beq     L06A9
	ldx     #$00
	lda     #$03
	jsr     _randint
	cpx     #$00
	bne     L06A9
	cmp     #$01
	bne     L06A9
;
; k = INVEN_HANDS;
;
	lda     #$1B
;
; else if ((inventory[INVEN_FEET].tval != TV_NOTHING) && (randint(3) ==1))
;
	jmp     L06B3
L06A9:	lda     _inventory+1220
	beq     L06AC
	ldx     #$00
	lda     #$03
	jsr     _randint
	cpx     #$00
	bne     L06AC
	cmp     #$01
	beq     L06C4
;
; else if (inventory[INVEN_BODY].tval != TV_NOTHING)
;
L06AC:	lda     _inventory+1020
	beq     L06AD
;
; k = INVEN_BODY;
;
	lda     #$19
;
; else if (inventory[INVEN_ARM].tval != TV_NOTHING)
;
	jmp     L06B3
L06AD:	lda     _inventory+1060
	beq     L06AE
;
; k = INVEN_ARM;
;
	lda     #$1A
;
; else if (inventory[INVEN_OUTER].tval != TV_NOTHING)
;
	jmp     L06B3
L06AE:	lda     _inventory+1260
	beq     L06AF
;
; k = INVEN_OUTER;
;
	lda     #$1F
;
; else if (inventory[INVEN_HEAD].tval != TV_NOTHING)
;
	jmp     L06B3
L06AF:	lda     _inventory+940
	beq     L06B0
;
; k = INVEN_HEAD;
;
	lda     #$17
;
; else if (inventory[INVEN_HANDS].tval != TV_NOTHING)
;
	jmp     L06B3
L06B0:	lda     _inventory+1100
	beq     L06B1
;
; k = INVEN_HANDS;
;
	lda     #$1B
;
; else if (inventory[INVEN_FEET].tval != TV_NOTHING)
;
	jmp     L06B3
L06B1:	lda     _inventory+1220
	beq     L06B3
;
; k = INVEN_FEET;
;
L06C4:	lda     #$1E
;
; k = 0;
;
L06B3:	ldy     #$0F
	sta     (sp),y
;
; if (k > 0) {
;
	lda     (sp),y
	jeq     L01DA
;
; i_ptr = &inventory[k];
;
	lda     (sp),y
	jsr     pusha0
	lda     #$28
	jsr     tosmula0
	clc
	adc     #<(_inventory)
	sta     regbank+2
	txa
	adc     #>(_inventory)
	sta     regbank+2+1
;
; bank_objdes(out_val2, i_ptr, FALSE, SCROLL1NUM);
;
	jsr     decsp5
	lda     #<(_out_val2)
	ldy     #$03
	sta     (sp),y
	iny
	lda     #>(_out_val2)
	sta     (sp),y
	lda     regbank+2
	ldy     #$01
	sta     (sp),y
	iny
	lda     regbank+2+1
	sta     (sp),y
	lda     #$00
	tay
	sta     (sp),y
	lda     #$29
	jsr     _bank_objdes
;
; sprintf(out_val1,"Your %s glows black, fades.", out_val2);
;
	jsr     decsp4
	lda     #<(_out_val1)
	ldy     #$02
	sta     (sp),y
	iny
	lda     #>(_out_val1)
	sta     (sp),y
	lda     #<(L0531)
	ldy     #$00
	sta     (sp),y
	iny
	lda     #>(L0531)
	sta     (sp),y
	lda     #<(_out_val2)
	ldx     #>(_out_val2)
	jsr     pushax
	ldy     #$06
	jsr     _sprintf
;
; bank_msg_print(out_val1, SCROLL1NUM);
;
	lda     #<(_out_val1)
	ldx     #>(_out_val1)
	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; vbxe_bank(VBXE_OBJBANK);
;
	lda     #$88
	jsr     _vbxe_bank
;
; i_ptr->name2 = SN_NULL;      // unmagic_name code in-line -SJ
;
	lda     #$00
	ldy     #$02
	sta     (regbank+2),y
;
; i_ptr->flags = TR_CURSED;
;
	lda     regbank+2
	ldx     regbank+2+1
	jsr     pushax
	ldx     #$00
	stx     sreg
	lda     #$80
	sta     sreg+1
	txa
	ldy     #$10
	jsr     steaxspidx
;
; i_ptr->toac = -randint(5) - randint(5);
;
	lda     regbank+2
	ldx     regbank+2+1
	jsr     pushax
	ldx     #$00
	lda     #$05
	jsr     _randint
	jsr     negax
	jsr     pushax
	ldx     #$00
	lda     #$05
	jsr     _randint
	jsr     tossubax
	ldy     #$23
	jsr     staspidx
;
; bank_calc_bonuses(SCROLL1NUM);
;
	lda     #$29
	jsr     _bank_calc_bonuses
;
; ident = TRUE;
;
	lda     #$01
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; ident = FALSE;
;
L06B4:	txa
	sta     regbank+5
;
; for (k = 0; k < randint(3); ++k) {
;
	dey
L067A:	sta     (sp),y
	lda     (sp),y
	jsr     pusha0
	lda     #$03
	jsr     _randint
	jsr     tosicmp
	jcs     L01DA
;
; y = char_row;
;
	lda     _char_row
	ldy     #$0D
	sta     (sp),y
;
; x = char_col;
;
	lda     _char_col
	dey
	sta     (sp),y
;
; ident |= bank_summon_undead(&y, &x, SCROLL1NUM);
;
	lda     regbank+5
	jsr     pusha0
	jsr     decsp4
	lda     sp
	ldx     sp+1
	clc
	adc     #$13
	bcc     L0559
	inx
L0559:	ldy     #$02
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	lda     sp
	ldx     sp+1
	clc
	adc     #$12
	bcc     L055B
	inx
L055B:	ldy     #$00
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	lda     #$29
	jsr     _bank_summon_undead
	jsr     tosorax
	sta     regbank+5
;
; for (k = 0; k < randint(3); ++k) {
;
	ldy     #$0F
	clc
	lda     #$01
	adc     (sp),y
	jmp     L067A
;
; ident = TRUE;
;
L06B5:	lda     #$01
	sta     regbank+5
;
; py.flags.blessed += randint(12)+6;     // in-lined bless code -SJ
;
	lda     #$0C
	jsr     _randint
	clc
	adc     #$06
	clc
	adc     _py+370
	sta     _py+370
;
; break;
;
	jmp     L01DA
;
; ident = TRUE;
;
L06B6:	lda     #$01
	sta     regbank+5
;
; py.flags.blessed += randint(24)+12;     // in-lined bless code -SJ
;
	lda     #$18
	jsr     _randint
	clc
	adc     #$0C
	clc
	adc     _py+370
	sta     _py+370
;
; break;
;
	jmp     L01DA
;
; ident = TRUE;
;
L06B7:	lda     #$01
	sta     regbank+5
;
; py.flags.blessed += randint(48)+24;     // in-lined bless code -SJ
;
	lda     #$30
	jsr     _randint
	clc
	adc     #$18
	clc
	adc     _py+370
	sta     _py+370
;
; break;
;
	jmp     L01DA
;
; ident = TRUE;
;
L06B8:	lda     #$01
	sta     regbank+5
;
; if (py.flags.word_recall == 0)
;
	lda     _py+374
	bne     L0579
;
; py.flags.word_recall = 25 + randint(30);
;
	lda     #$1E
	jsr     _randint
	clc
	adc     #$19
	sta     _py+374
;
; bank_msg_print("The air about you becomes charged.", SCROLL1NUM);
;
L0579:	lda     #<(L0580)
	ldx     #>(L0580)
;
; break;
;
	jmp     L06C3
;
; bank_destroy_area(char_row, char_col, SCROLL1NUM);
;
L0584:	jsr     decsp2
	lda     _char_row
	ldy     #$01
	sta     (sp),y
	lda     _char_col
	dey
	sta     (sp),y
	lda     #$29
	jsr     _bank_destroy_area
;
; ident = TRUE;
;
	lda     #$01
	sta     regbank+5
;
; break;
;
	jmp     L01DA
;
; bank_msg_print("Internal error in scroll()", SCROLL1NUM);
;
L058B:	lda     #<(L058D)
	ldx     #>(L058D)
L06C3:	jsr     pushax
	lda     #$29
	jsr     _bank_msg_print
;
; while (i != 0) {
;
L01DA:	ldy     #$14
L06B9:	jsr     ldeaxysp
	jsr     pusheax
	ldx     #$00
	stx     sreg
	stx     sreg+1
	txa
	jsr     tosneeax
	jne     L01D8
;
; vbxe_bank(VBXE_OBJBANK);
;
	lda     #$88
	jsr     _vbxe_bank
;
; i_ptr = &inventory[item_val];
;
	ldy     #$0E
	lda     (sp),y
	jsr     pusha0
	lda     #$28
	jsr     tosmula0
	clc
	adc     #<(_inventory)
	sta     regbank+2
	txa
	adc     #>(_inventory)
	sta     regbank+2+1
;
; if (ident) {
;
	lda     regbank+5
	beq     L0595
;
; if (!scroll1_known1_p(i_ptr)) {
;
	lda     regbank+2
	ldx     regbank+2+1
	jsr     _scroll1_known1_p
	tax
	bne     L05A8
;
; py.misc.exp += (i_ptr->level +(py.misc.lev >> 1)) / py.misc.lev;
;
	ldy     #$26
	lda     (regbank+2),y
	sta     ptr1
	lda     _py+48
	lsr     a
	clc
	adc     ptr1
	bcc     L066D
	inx
L066D:	jsr     pushax
	lda     _py+48
	jsr     tosudiva0
	ldy     #$00
	sty     sreg
	sty     sreg+1
	ldy     #<(_py+36)
	sty     ptr1
	ldy     #>(_py+36)
	jsr     laddeq
;
; bank_prt_experience(SCROLL1NUM);
;
	lda     #$29
	jsr     _bank_prt_experience
;
; bank_identify(&item_val, SCROLL1NUM);
;
	lda     sp
	ldx     sp+1
	clc
	adc     #$0E
	bcc     L05A2
	inx
L05A2:	jsr     pushax
	lda     #$29
	jsr     _bank_identify
;
; i_ptr = &inventory[item_val];      // CHECK: objbank still in?
;
	ldy     #$0E
	lda     (sp),y
	jsr     pusha0
	lda     #$28
	jsr     tosmula0
	clc
	adc     #<(_inventory)
	sta     regbank+2
	txa
	adc     #>(_inventory)
	sta     regbank+2+1
;
; else if (!scroll1_known1_p(i_ptr))
;
	jmp     L05A8
L0595:	lda     regbank+2
	ldx     regbank+2+1
	jsr     _scroll1_known1_p
	tax
	bne     L05A8
;
; scroll1_sample(i_ptr);
;
	lda     regbank+2
	ldx     regbank+2+1
	jsr     _scroll1_sample
;
; if (used_up) {
;
L05A8:	ldy     #$04
	lda     (sp),y
	beq     L05AD
;
; bank_desc_remain(item_val, SCROLL1NUM);
;
	ldy     #$0E
	lda     (sp),y
	jsr     pusha
	lda     #$29
	jsr     _bank_desc_remain
;
; bank_inven_destroy(item_val, SCROLL1NUM);
;
	ldy     #$0E
	lda     (sp),y
	jsr     pusha0
	lda     #$29
	jsr     _bank_inven_destroy
;
; }
;
L05AD:	ldy     #$00
L05B5:	lda     (sp),y
	sta     regbank+2,y
	iny
	cpy     #$04
	bne     L05B5
	ldy     #$15
	jmp     addysp

.endproc

